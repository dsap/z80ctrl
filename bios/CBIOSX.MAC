;****************************************************************************
;
;    CP/M 2.2 BIOS for z80ctrl
;    by J.B. Langston
;
;    Based on CPM 2.2 BIOS for SIMH by Peter Schorn
;    Track buffering inspired by CPM 2.2b BIOS by Mike Douglas
;    (I also borrowed Mike's format for the comments)
;
;****************************************************************************

	.8080
jpopcod	equ	(jmp)		; jp op-code
jpzopcd	equ	(jz)		; jp z op-code

	.Z80
	aseg
	org	100h
	maclib	MEMCFG.LIB	; define configuration parameters

	.phase	biosph
;----------------------------------------------------------------------------
; CP/M size & locations
;----------------------------------------------------------------------------
ccp		equ	ccpph		; ccp start address
bdos		equ	bdosph + 6	; bdos start address
bios		equ	biosph		; bios start address

;----------------------------------------------------------------------------
;  Altair floppy parameters
;----------------------------------------------------------------------------
wbotloc		equ	0000h		; warm boot location
bdosloc		equ	0005h		; BDOS entry location
bioserr		equ	1		; 1 indicates BIOS error
cdisk		equ	0004h		; current disk location
ndisks		equ	8		; total number of Altair disks
tracks		equ	254		; number of tracks for regular drives
asecsiz		equ	137		; sector size Altair
csecsiz		equ	0080h		; sector size CP/M
spt		equ	32		; sectors per track
sptmask		equ	spt-1		; mask corresponding to 'spt'
dirent		equ	255		; number of directory entries
restrk		equ	6		; reserved tracks
dsm		equ	1efh		; maximum data block number for disk 7
cks		equ	(dirent+1)/4	; checksum space
rom		equ	0ff00h		; address of Altair bootstrap loader in ROM
bootdr1		equ	rom+0037h	; taken from dskboot (offset unitnooffset1)
bootdr2		equ	rom+00b4h	; taken from dskboot (offset unitnooffset2)

;----------------------------------------------------------------------------
; Altair disk controller 
;----------------------------------------------------------------------------
;	Address		Mode	Function
;	-------		----	--------
;	selout		Out	Selects and enables controller and drive
;	statin		In	Indicates status of drive and controller
;	dskcon		Out	Controls disk function
;	secpos		In	Indicates current sector position of disk
;	dskwrit		Out	Write data
;	dskread		In	Read data

selout		equ	8	; port to select and enable controller and drive (OUT)
;	+---+---+---+---+---+---+---+---+
;	| C | X | X | X |   Device      |
;	+---+---+---+---+---+---+---+---+
;
;	C	= If this bit is 1, the disk controller selected by 'device' is
;		  cleared. If the bit is zero, 'device' is selected as the
;		  device being controlled by subsequent I/O operations.
;	X	= not used
;	Device	= value zero thru 15, selects drive to be controlled.

statin		equ	8	; port indicating status of drive and controller (IN)
;	+---+---+---+---+---+---+---+---+
;	| R | Z | I | X | X | H | M | W |
;	+---+---+---+---+---+---+---+---+
;
;	W - When 0, write circuit ready to write another byte.
;	M - When 0, head movement is allowed
;	H - When 0, indicates head is loaded for read/write
;	X - not used (will be 0)
;	I - When 0, indicates interrupts enabled (not used this simulator)
;	Z - When 0, indicates head is on track 0
;	R - When 0, indicates that read circuit has new byte to read

dskcon		equ	9	; port to control disc function (OUT)
;	+---+---+---+---+---+---+---+---+
;	| W | C | D | E | U | H | O | I |
;	+---+---+---+---+---+---+---+---+
;
;	I - When 1, steps head IN one track
;	O - When 1, steps head OUT one track
;	H - When 1, loads head to drive surface
;	U - When 1, unloads head
;	E - Enables interrupts (ignored by this simulator)
;	D - Disables interrupts (ignored by this simulator)
;	C - When 1 lowers head current (ignored by this simulator)
;	W - When 1, starts Write Enable sequence:
;	    W bit on device 'statin' (see above) will go 1 and data will be read from
;	    port 'dskread' until 137 bytes have been read by the controller from
;	    that port. The W bit will go off then, and the sector data will be written
;	    to disk. Before you do this, you must have stepped the track to the desired
;	    number, and waited until the right sector number is presented on
;	    device 'secpos', then set this bit.

secpos		equ	9	; port to indicate current sector position of disk (IN)
;	As the sectors pass by the read head, they are counted and the
;	number of the current one is available in this register.
;
;	+---+---+---+---+---+---+---+---+
;	| X | X |  Sector Number    | T |
;	+---+---+---+---+---+---+---+---+
;
;	X		= Not used
;	Sector number	= binary of the sector number currently under the head, 0-31.
;	T		= Sector True, is a 1 when the sector is positioned to read or write.

dskwrit		equ	10	; port to write data (OUT)
dskread		equ	10	; port to read data (IN)

; masks for disk controller (statin)
mhm		equ	02h	; head movement mask
mtzero		equ	40h	; head on track zero mask
mall		equ	0ffh	; everything ok mask

; commands for disk controller (dskcon)
cstepin		equ	01h	; step in command
cstepot		equ	02h	; step out command
cload		equ	04h	; load head to drive surface command
cuload		equ	08h	; unload head from drive surface command
cwrseq		equ	80h	; 'start write enable sequence' command

; deslect disk
deselect 	equ 	80h
;----------------------------------------------------------------------------
; z80ctrl DMA controller 
;----------------------------------------------------------------------------
dmaport		equ     0bh     ; z80ctrl DMA port
dmaunset	equ     0       ; address is not set
dmahalfset	equ     1       ; only lsb is set
dmaset		equ     2       ; address is set
cmdreset	equ     0       ; reset the dma address
cmddpb		equ     1       ; get the disk parameter block for selected disk
cmdread		equ     2       ; read the selected track from the selected disk
cmdwrite	equ     3       ; write the selected track to the selected disk
;----------------------------------------------------------------------------
; 2SIO Serial Board 
;----------------------------------------------------------------------------
;	All I/O is via programmed I/O. Each device has a status port
;	and a data port. A write to the status port can select
;	some options for the device although the simulator only
;	recognizes the reset command (0x03).
;	A read of the status port gets the port status:
;
;	+---+---+---+---+---+---+---+---+
;	| X | X | X | X | X | X | O | I |
;	+---+---+---+---+---+---+---+---+
;
;	I - A 1 in this bit position means a character has been received
;		on the data port and is ready to be read.
;	O - A 1 in this bit means the port is ready to receive a character
;		on the data port and transmit it out over the serial line.
;
;	A read to the data port gets the buffered character, a write
;	to the data port writes the character to the device.
constat	equ	16		; sio port 1 status port
condata	equ	17		; sio port 1 data port
punstat	equ	18		; sio port 2 status port
pundata	equ	19		; sio port 2 data port

; masks for SIO controller (constat, punstat)
mout	equ	02h		; output allowed mask

; commands for SIO controller (constat, punstat)
creset	equ	3		; reset command

;-----------------------------------------------------------------------------
;  Misc equates
;-----------------------------------------------------------------------------
cr	equ	13		; Carriage Return
lf	equ	10		; Line Feed
undef	equ	0FFh		;undefined value

;-----------------------------------------------------------------------------
;  BIOS Entry Jump Table
;-----------------------------------------------------------------------------
	jp	boot		; cold start
wboote:	jp	wboot		; warm start (reboot)
	jp	const		; console status
	jp	conin		; console input
	jp	conout		; console output
	jp	list		; list character out
	jp	punch		; punch character out
	jp	reader		; read character in
	jp	home		; move disk head to home
	jp	seldsk		; select disk drive
	jp	settrk		; set track number
	jp	setsec		; set sector number
	jp	setdma		; set disk memory read/write address
	jp	read		; read sector
	jp	write		; write sector
	jp	listst		; list dev status test
	jp	sectrn		; sector translate

;----------------------------------------------------------------------------
; boot - Cold boot BIOS entry. CPM is already loaded in memory. Initialize
;    serial ports, display welcome banner and enter the CCP.
;----------------------------------------------------------------------------
boot:	ld	sp,chk02
	xor	a
	ld	(cdisk),a
	ld	hl,dmadrive
	call	dmainit		; detect and initialize dma
	ld	de,msg1		; print welcome message
	call	msg

;----------------------------------------------------------------------------
; entcpm - Initialization for CPM that is common to both warm
;    boot and cold boot.
;----------------------------------------------------------------------------
entcpm:	ld	a,jpopcod	; jp instruction code
	ld	(wbotloc),a	; store at entry to warm boot
	ld	hl,wboote	; get jump location
	ld	(wbotloc+1),hl	; and store it after jp instruction
	ld	(bdosloc),a	; jp instruction code for entry to BDOS
	ld	hl,bdos		; get jump location
	ld	(bdosloc+1),hl	; and store it after jp instruction
	ld	a,creset	; reset command
	out	(constat),a	; reset console device
	out	(punstat),a	; and list/punch device
	ld	bc,0080h
	call	setdma
	ld	a,(cdisk)	; get current disk
	cp	ndisks		; does it exist?
	jp	c,ent1		; yes, proceed
	xor	a		; otherwise use first disk
	ld	(cdisk),a	; and make it current disk
ent1:	ld	c,a		; inform CCP
	ei
	jp	ccp

;----------------------------------------------------------------------------
; print the message pointed to by <DE> and terminated by '$' to the console
; leaves <b> unchanged
;----------------------------------------------------------------------------
msg:	ld	a,(de)		; get character
	cp	'$'		; is is the terminating character?
	ret	z		; yes, we are done
	ld	c,a		; 'conout' expects the character in <C>
	call	conout		; disply it on console
	inc	de		; point to next character
	jp	msg		; and repeat

;----------------------------------------------------------------------------
; wBoot - Warm boot BIOS entry. Reload CPM from disk up to, but
;    not including the BIOS. Re-enter CPM after loading.
;----------------------------------------------------------------------------
wboot:	ld	sp,chk02
	ld	a,(bootdr1)	; make sure that ccp and bdos are loaded from correct disk
	out	(selout),a	; select it
	ld	a,cload		; load head command
	out	(dskcon),a	; load head to drive surface
	call	dhome		; position disk head on track zero
	ld	de,ccp		; destination load address
	ld	b,17		; first sector to read on track zero
nextsc:	push	bc		; save current sector to read, <C> is undefined
	push	de		; save current destination load address
	call	seclp2		; position to sector in <B>
	call	blread		; read the sector
	pop	de		; restore current destination load address, <DE> is destination
	ld	hl,trkbuf+3	; ignore first three byte of buffer, <HL> is source
	ldir			; <BC> has been set by 'blread'
	pop	bc		; <B> is current sector, <C> is undefined
	ld	hl,bios		; when <DE> reaches this address we are done
	ld	a,d
	cp	h
	jp	nz,decide
	ld	a,e
	cp	l
decide:	jp	nc,gotoit	; jump if everything loaded
	inc	b		; compute next sector number
	inc	b
	ld	a,b
	cp	spt		; compare new sector number with sectors per track
	jp	c,nextsc	; continue if less
	ld	b,1		; otherwise prepare for odd numbered sectors
	jp	z,nextsc	; if old sector number was equal to sectors per track
	call	whmove		; loop until head movement is allowed
	ld	a,cstepin	; step in one track command
	out	(dskcon),a	; step in one track
	ld	b,0		; start with even sectors
	jp	nextsc
gotoit:	ld	a,(bootdr2)	; clear disk controller of correct disk
	out	(selout),a	; do it
	ld	hl,curtrk	; start address of table for current track positions
	ld	b,ndisks	; number of disks
resett:	ld	(hl),undef	; reset entry for disk
	inc	hl		; point to next entry
	dec	b		; decrement counter for disks to go
	jp	nz,resett	; jump if not yet done
	jp	entcpm

;---------------------------------------------------------------------------
;  CON device I/O
;---------------------------------------------------------------------------
; conSt - Console status BIOS entry point. Return FFh if character ready,
;    return zero otherwise. 
const:	in	a,(constat)	; get console status
	rra			; I bit into carry
	ld	a,0		; prepare no character available
	ret	nc		; I bit clear means no character, done
	dec	a		; character available, result is 0ffh
	ret			; done

; conIn - Console input BIOS entry point. Wait for console input and
;    return character in a. Console input is used as an idle indicator
;    and as a good time to flush a dirty track buffer, unload the head, 
;    and invalidate the track buffer.
conin:	in	a,(constat)	; get console status
	rra			; I bit into carry
	jp	nc,conin	; jump back if no character available
	in	a,(condata)	; read character
	and	7fh		; clear bit 8
	ret

; conOut - Console output BIOS entry point. Output the character in c.
;   If the sndNull flags is true (i.e., it was determined during cold start
;   that the console is a Teletype), then follow CR with a null.
conout:	in	a,(constat)	; get console status
	and	mout		; mask output bit
	jp	z,conout	; jump back if not ready for output
	ld	a,c		; prepare character for output
	out	(condata),a	; do it
	ret

;---------------------------------------------------------------------------
;  LST device I/O
;---------------------------------------------------------------------------
; listSt - List output test BIOS entry point. Return 0FFh if list device
;    is ready, 0 if not ready
listst:	xor	a		; <A> := 0 means no error
	ret


; list - List output character BIOS entry point. Send the character
;    passed in c out the list port
list:				; list aliased to punch
;---------------------------------------------------------------------------
; PUN device - Punch output character BIOS entry point. Byte to send in c.
;---------------------------------------------------------------------------
punch:	in	a,(punstat)	; get punch status
	and	mout		; mask output bit
	jp	z,punch		; jump back if not ready for output
	ld	a,c		; prepare character for output
	out	(pundata),a	; do it
	ret

;---------------------------------------------------------------------------
; RDR device - Reader input character BIOS entry point. Return in a
;---------------------------------------------------------------------------
reader:	in	a,(punstat)	; get reader status
	rra			; I bit into carry
	jp	nc,reader	; jump back if no character available
	in	a,(pundata)	; read character
	ret

;----------------------------------------------------------------------------
; seldsk - Select Disk BIOS entry. c contains the disk number to select.
;    Validate the disk number and return a pointer to the disk parameter
;    header in hl. Zero is returned in hl for invalid drive number. The
;    disk number is stored in drive. No drive activity takes place.
;
; On Entry
;    c = disk number to select
;
; On Exit
;    drive = disk number to select
;    Success: hl->DPH for this drive. Error: hl=0
;    Clobbers a,d,e,H,L
;----------------------------------------------------------------------------
seldsk:	ld	hl,0		; select disk number
	ld	a,c
	ld	(drive),a
	cp	ndisks		; number of disk drives
	ret	nc		; error - disk number too high
	ld	l,a		; <HL> := disk number
	ld	h,0
	add	hl,hl		; disk number * 2
	add	hl,hl		; disk number * 4
	add	hl,hl		; disk number * 8
	add	hl,hl		; disk number * 16
	ld	de,dphead	; dphead entries have size of 16 bytes
	add	hl,de		; <HL> = 16 * disknumber + dphead
	ret

;----------------------------------------------------------------------------
; home - Home BIOS entry. Set track to zero. No drive activity takes place.
;
; On Entry
;
; On Exit
;    track set to zero
;    Clobbers a
;----------------------------------------------------------------------------
home:	ld	bc,0		; move to track 00
				; fall into settrk

;----------------------------------------------------------------------------
; settrk - Set Track BIOS entry. c contains the desired track number.
;    The track number is saved in track for later use.
;
; On Entry
;    c = track number to set
;
; On Exit
;    track = track specified in c
;    Clobbers a
;----------------------------------------------------------------------------
settrk:	ld	l,c		; save track
	ld	h,b
	ld	(track),hl
	ret

;----------------------------------------------------------------------------
; setsec - Set Sector BIOS entry. c contains the 1-indexed CPM physical 
;   sector. Saved in sector as a zero-indexed value.  
;
; On Entry
;    c = 1-indexed sector number to set
;
; On Exit
;    sector = zero-indexed sector number
;    Clobbers a
;----------------------------------------------------------------------------
setsec:	ld	a,c		; set sector
	ld	(sector),a
	ret

;----------------------------------------------------------------------------
; sectrn - Sector translation BIOS entry. Convert zero-indexed logical 
;    sector number in bc to a CPM one-indexed physical sector number in hl
;    based on the translate table passed in de.
;
; On Entry
;    bc = logical sector number
;    de->sector translate table for selected drive
;
; On Exit
;    hl = physical sector number
;    Clobbers b,d,e,H,L
;----------------------------------------------------------------------------
sectrn:
	ex	de,hl		; <HL> := translate table address
	add	hl,bc		; add sector number
	ld	l,(hl)		; get pointed to byte
	ld	h,0		; set upper byte to zero
	ret			; done

;----------------------------------------------------------------------------
; setdma - Set DMA BIOS entry. bc contains the address for reading or
;    writing sector data for subsequent I/O operations. The address is
;    stored in dmaad.
;
; On Entry
;    bc = I/O buffer address
;
; On Exit
;    dmaad = address specified in bc
;    Clobbers H,L
;----------------------------------------------------------------------------
setdma:	ld	l,c		; set dma address
	ld	h,b
	ld	(dmaad),hl
	ret


;----------------------------------------------------------------------------
; z80ctrl DMA routines
;----------------------------------------------------------------------------
; initialize the dma address
;   HL = address to set
dmainit:
	ld	a,0		; disable dma initially
	ld	(dmaena),a
	ld	c,dmaport	; talking to the disk dma port
	in	a,(c)		; check status of the dma address
	cp	dmaunset	; if it's unset, we're ready to set a new one
	jp	z,sndaddr
	cp	dmaset		; is the address fully set?
	jp	nz,rstaddr	; if so, we're ready to reset it
	cp	dmahalfset	; only remaining possiblity is half set
	ret	nz		; if not, abort because of unexpected result
	out	(c),a		; send dummy byte before resetting
	in	a,(c)		; confirm that address is now fully set
	cp	dmaset
	ret	nz		; if not, abort because of unexpected result
rstaddr:
	ld	a,cmdreset	; send the command to reset the address
	out	(c),a
	in	a,(c)		; confirm that dma address is now unset
	cp	dmaunset
	ret	nz		; if not, abort because of unexpected result
sndaddr:
	out	(c),l		; send the address of the DMA block
	in	a,(c)		; confirm that address is now half set
	cp	dmahalfset
	ret	nz		; if not, abort because of unexpected result
	out	(c),h
	in	a,(c)		; verify that the address is set now
	cp	dmaset
	ret	nz		; if not, abort because of unexpected result
	ld	a,1		; everything worked as expected, enable dma
	ld	(dmaena),a
	ret

; set dma parameters
dmaparam:
	ld	a,(drive)	; set disk number
	ld	(dmadrive),a
	ld	hl,(track)	; set track number
	ld	(dmatrack),hl
	ret
;----------------------------------------------------------------------------
; read - Read sector BIOS entry. Read one sector using the drive, 
;    track, sector, and dmaad previously specified.
;
; On Entry
;    drive = drive to read from
;    track = track to read from
;    sector = sector number to read (0-31)
;    dmaad = address of buffer to read into
;
; On Exit
;    If read successful
;	sector read into (dmaad)
;	hl = (dmaad) + csecsiz
;	a=0, Z flag set true
;    Else
;	a=1, Z flag set false
;    Interrupts enabled
;    Clobbers all
;----------------------------------------------------------------------------
read:
	ld	a,(dmaena)	; check if DMA is enabled
	or	a
	jp	z,altread	; if not, fall back to altair interface
	;call	ckflush		; flush track buffer if needed
	call	readtrk		; fill track buffer if needed
	jp	nz,exitdio	; track read error, exit
	ld	a,(sector)
	dec	a
	call	csecaddr		; HL=address of sector in trkbuf
	ld	de,(dmaad)	; DE=destination address
	ld	bc,csecsiz	; BC=128 bytes
	ldir			; copy
	xor	a
	ret
exitdio:
	ld	a,bioserr	; return error code
	ret	
altread:
	call	poshed		; select disk 'drive' and position disk head to 'track'
	call	secget		; position head to desired sector
	di
	call	blread
	ld	a,cuload	; unload head command
	out	(dskcon),a	; do it
	ei
	ld	de,trkbuf+3	; address of sector just read
	ld	hl,(dmaad)	; destination address
	ex	de,hl		; prepare for ldir
	ldir			; move

;----------------------------------------------------------------------------
; write - Write sector BIOS entry. Write one sector using the drive,
;    track, sector and dmaad specified. 
;
; On Entry
;    drive = drive to write
;    track = track to write
;    sector = sector number to write (0-31)
;    dmaad = address of buffer to write from
;
; On Exit
;    If successful
;	sector written to trkbuf from (dmaad)
;	a=0, Z flag set true
;    Else
;	a=1, Z flag set false
;    Interrupts enabled
;    Clobbers all
;----------------------------------------------------------------------------
write:
	ld	a,undef		; invalidate buffered data
	ld	(bfdrive),a
	ld	(bftrack),a
	call	poshed		; select desired disk and position to desired track
	call	secget		; position head to desired sector
	ld	hl,(dmaad)	; source of sector is in 'dmaad'
	ld	de,trkbuf+3	; destination inside local buffer
	ld	bc,csecsiz	; sector size is 128
	ldir			; block move
	ld	a,cwrseq	; command for 'start write enable sequence'
	out	(dskcon),a	; do it
	di
	ld	hl,trkbuf	; point to first byte in local buffer
	ld	b,asecsiz+1	; number of bytes to write (additional byte triggers 'real' write)
wready:	in	a,(statin)	; get status
	rra			; get bit for ready for write
	jp	c,wready	; loop until ready for write
	ld	a,(hl)		; byte to write
	out	(dskwrit),a	; write byte
	inc	hl		; point to next byte
	dec	b		; decrement counter of bytes
	jp	nz,wready	; jp if not done
	ld	a,cuload	; unload head command
	out	(dskcon),a	; do it
	ei
	xor	a		; <A> := 0 means no error
	ret

;---------------------------------------------------------------------------
; csecaddr - Convert hard sector in a to address within trkbuf for
;    the specified sector
;
; On Entry
;    a = Hard sector number
;
; On Exit
;    hl->sector buffer in trkbuf
;    Clobbers a,b,c,H,L
;---------------------------------------------------------------------------
csecaddr:
	ld	hl,secaddr	; hl->sector address table
	ld	b,0		; form bc=sector*2
	rlca			; a=sector*2 (2 bytes per table entry)
	ld	c,a		; bc=sector*2
	add	hl,bc		; hl->address table entry for passed sector
	
	ld	a,(hl)		; a=lsb of sector buffer address
	inc	hl		;
	ld	H,(hl)		; H=msb of sector buffer address
	ld	L,a		; hl->sector buffer
	ret			;

;----------------------------------------------------------------------------
; ckflush - Check if track buffer should be flushed. This
;    function must be called before any drive selection or seek
;    operation. The buffer is flushed if the bfdirty flag is
;    set and the drive or track number are different than the
;    buffered track.
;
; On Entry
;    Drive still selected and on same track as in trkbuf
;    drive, track updated for the new I/O call
;
; On Exit
;    Zero true for no error, zero false if write error occured
;    Clobbers all
;----------------------------------------------------------------------------
ckflush:
	ld	a,(bfdirty)	; see if track buffer is dirty
	or	a
	ret	z		; no, exit with Z set
	ld	a,(bfdrive)	; L=buffered drive
	ld	l,a
	ld	a,(drive)	; A=requested drive
	cp	l		; same drive?
	jp	nz,wrttrk	; no, flush
	ld	a,(track)	; a=requested track number
	cp	H		; same track?
	ret	z		; yes, no need to flush
wrttrk:
	xor	a
	ld	(bfdirty),a	; clear buffer dirty flag
	call	dmaparam	; set DMA parameters
	ld	a,cmdwrite	; initiate DMA read
	out	(dmaport),a
	ld	a,(dmaerr)	; set zero flag if there was an error
	or	a
	ret

;----------------------------------------------------------------------------
; readtrk- read full track into track buffer if the requested 
;    drive (drive) or track (track) does not match the buffered
;    drive (bfdrive) or buffered track (bftrack). The status byte
;    at the start of each sector is set to zero if the sector is
;    good, non-zero if the sector couldn't be read.
;
; On Entry
;    drive = drive to read
;    track = track to read
;    bfdrive = drive from which trkbuf was filled
;    bftrack = track from which trkbuf was filled
;
; On Exit
;    track on drive read into trkbuf
;    Zero true if track read or already there, zero false otherwise
;    Clobbers all
;----------------------------------------------------------------------------
readtrk:
	ld	a,(drive)	; A=requested drive
	ld	hl,bfdrive	; HL=pointer to buffered drive
	cp	(hl)		; same drive?
	jp	nz,rtnew	; no, load track from new drive
	ld	hl,(track)	; HL=requested track
	ld	de,(bftrack)	; DE=buffered track
	or	a		; 16-bit compare
	sbc	hl,de
	add 	hl,de
	cp	h		; same track?
	ret	z		; yes, track already buffered
rtnew:
	ld	a,undef		; invalidate buffered data
	ld	(bfdrive),a
	ld	(bftrack),a
	call	dmaparam	; set DMA parameters
	ld	a,cmdread	; initiate DMA read
	out	(dmaport),a
	ld	a,(dmaerr)	; set zero flag if there was an error
	or	a
	ret	nz
	ld	a,(dmadrive)	; set buffered drive and track
	ld	(bfdrive),a	; to the ones just read
	ld	hl,(dmatrack)
	ld	(dmatrack),hl
	ret

;-----------------------------------------------------------------------------
;  Low-level disk routines
;-----------------------------------------------------------------------------
; Postcondition: 'trkbuf' contains 'asecsiz' many bytes, <BC> is set to 'csecsiz'
blread:	ld	hl,trkbuf	; address of sector buffer
	ld	e,asecsiz	; number of bytes to read
blrd1:	in	a,(statin)	; get disk status
	or	a		; set sign of byte
	jp	m,blrd1		; loop until disk has new byte to read
	in	a,(dskread)	; read byte of sector
	ld	(hl),a		; store into buffer
	inc	hl		; point to next position in buffer
	dec	e		; decrement size counter
	jp	nz,blrd1	; if not zero, we need to continue
	ld	bc,csecsiz	; sector size in preparation for call to 'ldir'
	ret

; position disk on track zero, <A> == 0 at the end
dhome:	in	a,(statin)	; position disk to track 0
	and	mtzero		; mask for 'head is on track zero'
	ret	z		; track zero reached, done
	call	whmove		; loop until head movement is allowed
	ld	a,cstepot	; command for 'step head out one track'
	out	(dskcon),a	; do it
	jp	dhome		; try again

; Select disk 'drive' and position disk head to 'track'
poshed:	call	calcd		; position altair disk head
	ld	a,d		; select disk <D>, cur track in <B>
	out	(selout),a	; select disk
	in	a,(statin)	; get status of selected drive
	cp	mall		; ok?
	jp	z,selerr	; no!
	ld	a,b		; <B> := track of selected disk
	cp	undef		; compare with non-existing track
	jp	nz,alseek	; if a regular track, proceed to seek
	call	dhome		; position disk to track 0
	ld	b,a		; <B> := 0 (current track)
;Input:		location 'track' contains desired track
;		<B> contains current track
;Output:	desired track is reached and stored in track array
alseek:	ld	a,(track)	; seek to 'track' (cur track in b)
	ld	e,a		; <E> := desired track
	ld	a,b		; <A> := current track
	sub	e		; <A> := current track - desired track
	ret	z		; we are already at desired track
	ld	e,a		; e is the number of "step in" or "step out"
	jp	c,stpin		; current track < desired track
	ld	c,cstepot	; command for step head out one track
	jp	aseek		; perform steps
stpin:	ld	c,cstepin	; command for step head in one track
	cpl			; <A> := ~(current track - desired track)
	inc	a		; <A> := desired track - current track (positive)
	ld	e,a		; <E> is positive number of tracks to move
aseek:	call	whmove		; loop until head movement is allowed
	ld	a,c		; get command (step in or step out)
	out	(dskcon),a	; perform it
	dec	e		; next iteration
	jp	nz,aseek	; loop if not done
	call	calcd		; get pointer to 'track' of 'drive'
	ld	a,(track)	; this is the current track
	ld	(hl),a		; update 'track' of 'drive'
	ret
selerr:	pop	hl		; discard return address
	ld	a,bioserr	; <A> := 1 means error
	ret

; loop until head movement is allowed
whmove:	in	a,(statin)	; get status
	and	mhm		; mask for 'head movement allowed'
	jp	nz,whmove	; loop until movement allowed
	ret

; Input:	<none> - implicit input is location 'drive'
; Output:	<B> contains the current track of 'drive'
;		<A>, <D> and <E> contain 'drive'
;		<HL> points to 'track' of 'drive'
calcd:	ld	a,(drive)	; get 'drive'
	ld	e,a		; <E> := 'drive'
	ld	hl,curtrk
	ld	d,0
	add	hl,de		; <HL> points to 'track' of 'drive'
	ld	b,(hl)		; <B> := 'track' of 'drive'
	ld	d,e		; <E> := 'drive'
	ret

; Input:	'sector' contains desired sector number
; Output:	head is positioned at desired sector
secget:	ld	a,cload		; command to load head to drive surface
	out	(dskcon),a	; do it
	ld	a,(sector)	; <A> := desired sector
	dec	a		; adjust to range 0..(spt-1)
	ld	b,a		; <B> := adjusted, desired sector
	cp	spt		; compare with sectors per track
	jp	c,seclp2	; desired sector is less than total sectors per track, ok
	ld	de,secmsg	; prepare error message
	call	msg		; print it
	halt			; not much we can do
seclp2:	in	a,(secpos)	; get sector position
	rra			; rotate T bit into carry
	jp	c,seclp2	; loop until sector is positioned to read or write
	and	sptmask		; <A> now contains the sector under the head
	cp	b		; compare with desired sector
	jp	nz,seclp2	; repeat if not equal
	ret

;******************************************************************************
;
;   BIOS Data Area
;
;******************************************************************************
;---------------------------------------------------------------------------
; secaddr - Sector address table. Returns sector buffer address within
;    the track buffer when indexed by hard sector number. Each sector
;    requires asecsiz bytes.
;---------------------------------------------------------------------------
secaddr:	
	defw	trkbuf+00*asecsiz+3,trkbuf+01*asecsiz+3,trkbuf+02*asecsiz+3
	defw	trkbuf+03*asecsiz+3,trkbuf+04*asecsiz+3,trkbuf+05*asecsiz+3
	defw	trkbuf+06*asecsiz+3,trkbuf+07*asecsiz+3,trkbuf+08*asecsiz+3
	defw	trkbuf+09*asecsiz+3,trkbuf+10*asecsiz+3,trkbuf+11*asecsiz+3
	defw	trkbuf+12*asecsiz+3,trkbuf+13*asecsiz+3,trkbuf+14*asecsiz+3
	defw	trkbuf+15*asecsiz+3,trkbuf+16*asecsiz+3,trkbuf+17*asecsiz+3
	defw	trkbuf+18*asecsiz+3,trkbuf+19*asecsiz+3,trkbuf+20*asecsiz+3
	defw	trkbuf+21*asecsiz+3,trkbuf+22*asecsiz+3,trkbuf+23*asecsiz+3
	defw	trkbuf+24*asecsiz+3,trkbuf+25*asecsiz+3,trkbuf+26*asecsiz+3
	defw	trkbuf+27*asecsiz+3,trkbuf+28*asecsiz+3,trkbuf+29*asecsiz+3
	defw	trkbuf+30*asecsiz+3,trkbuf+31*asecsiz+3

;-----------------------------------------------------------------------------
; dphead - disk parameter header for each drive
;-----------------------------------------------------------------------------
dphead:	dw	skewtbl,0,0,0,dirbf,dpb,chk00,all00
	dw	skewtbl,0,0,0,dirbf,dpb,chk01,all01
	dw	skewtbl,0,0,0,dirbf,dpb,chk02,all02
	dw	skewtbl,0,0,0,dirbf,dpb,chk03,all03
	dw	skewtbl,0,0,0,dirbf,dpb,chk04,all04
	dw	skewtbl,0,0,0,dirbf,dpb,chk05,all05
	dw	skewtbl,0,0,0,dirbf,dpb,chk06,all06
	dw	skewtbl,0,0,0,dirbf,dpb,chk07,all07

;-----------------------------------------------------------------------------
; dpb - disk parameter block. This table gives a block size of 1024 bytes
;   and 64 directory entries. 
;-----------------------------------------------------------------------------
dpb:	dw	spt		; spt, sectors per track
	db	4		; allocation block shift factor, bsh
	db	15		; data allocation block mask, blm, allocation size (bls) = 2048
	db	0		; extent mask
	dw	dsm		; dsm, maximum data block number
	dw	dirent		; drm, number of directory entries - 1
	db	0f0h,0		; al0, al1, 4 blocks reserved to hold all entries
				; 256 * 32 = 4 * 2048
				; (drm+1) * 32 = (number of bits in al0 and al1) * bls
	dw	cks		; cks = (drm + 1)/4
	dw	restrk		; off, number of tracks skipped at beginning of disk
	db	0		; PSH
	db	0		; PHM

; speedball (copylib) skewtable
skewtbl:
	db	01,18,03,20,05,22,07,24
	db	09,26,11,28,13,30,15,32
	db	17,02,19,04,21,06,23,08
	db	25,10,27,12,29,14,31,16

msg1:	db	cr, lf
	db	'0' + (msize/10)
	db	'0' + (msize MOD 10)
	db	'K CP/M Version 2.2 for z80ctrl', cr, lf, '$'
secmsg:	db	cr, lf, 'Cannot find sector in register <b>', cr, lf, '$'

; position disk drive head
curtrk:	db	undef		; current track# drive 0 (logical 1)
	db	undef		; current track# drive 1 (logical 2)
	db	undef		; current track# drive 2 (logical 3)
	db	undef		; current track# drive 3 (logical 4)
	db	undef		; current track# drive 4 (logical 5)
	db	undef		; current track# drive 5 (logical 6)
	db	undef		; current track# drive 6 (logical 7)
	db	undef		; current track# drive 7 (logical 8)

drive:	db	0
track:	dw	0	; MUST follow drive
sector:	db	0
dmaad:	dw	0

;-----------------------------------------------------------------------------
;  Disk scratchpad areas defined in the DPH table
;-----------------------------------------------------------------------------
dirbf:	ds	128		; directory work space
all00:	ds	((dsm+1)/8)+1
all01:	ds	((dsm+1)/8)+1
all02:	ds	((dsm+1)/8)+1
all03:	ds	((dsm+1)/8)+1
all04:	ds	((dsm+1)/8)+1
all05:	ds	((dsm+1)/8)+1
all06:	ds	((dsm+1)/8)+1
all07:	ds	((dsm+1)/8)+1

chk00:	ds	cks
chk01:	ds	cks
chk02:	ds	cks
chk03:	ds	cks
chk04:	ds	cks
chk05:	ds	cks
chk06:	ds	cks
chk07:	ds	cks

;-----------------------------------------------------------------------------
;  DMA interface
;-----------------------------------------------------------------------------
dmadrive:	db	0		; dma drive
dmatrack:	dw	0		; dma track
dmasector:	db	0		; dma sector
dmatrklen: 	db	spt		; track length (sectors per track)
dmaseclen:	db	asecsiz		; sector length (bytes per sector)
dmatarget:	dw	trkbuf		; DMA transfer target 
dmadpb:		dw	dpb		; Disk parameter block address
dmaskew:	dw	skewtbl		; Skew table address
dmaerr:		dw	undef		; DMA error status
dmaena:		db	0		; DMA enabled flag

;-----------------------------------------------------------------------------
;  Disk buffering
;-----------------------------------------------------------------------------
bfdirty:	db	0		; non-zero if buffer has been written to
bfdrive:	db	undef		; drive currently in track buffer
bftrack:	dw	undef		; currently buffered track (MUST follow bfdrive)
trkbuf:		ds	(asecsiz*spt)	; track buffer


biosend	equ	$
biossiz	equ	biosend-bios

; fill remainder with 0

fillmod	equ	biossiz AND 00ffh
	if	fillmod gt 0
fillsiz	equ	100h-fillmod
	ds	fillsiz
	endif

    if2
padjust	macro	?newsiz
	.printx	/Adjust bioslen in MEMCFG.LIB to ?newsiz/
	endm

psize	macro	?val1,?val2,?val3,?val4
	.printx	/BIOS extends from ?val1 to ?val2 (Size ?val3, bioslen = ?val4)/
	endm

psave	macro	?value
	.printx	/SAVE ?value CPMBOOT.COM/
	endm

	.radix	16
	psize	%bios,%biosend,%biossiz,%bioslen
	if	biossiz gt bioslen
	padjust	%(100h*((biossiz + 0ffh) / 100h))
	endif
	.radix	10
	if	biosend gt 0ff00h
	.printx	/Warning: BIOS extends into Altair ROM/
	endif

    	psave	%(9+(ccplen + bdoslen + bioslen) / 100h)

	endif

	.dephase

	end
